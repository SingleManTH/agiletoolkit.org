# ApiWeb and ApiCLI

When building a command-line utility using Agile Toolkit, you are unlikely to use the ApiFrontend - which is an application class for a fully-featured web software. The ApiCLI and ApiWeb are parents of ApiFrontend but they are much more minimalistic:* ApiCLI provides methods such as dbConnect() and getConfig(), which are useful in command-line applications. This class also initializes some essential system controllers - PathFinder and Logger.* ApiWeb extends ApiCLI to add proper headers, support for session control, support for stickyGET but also implements main() method. This class will also render all the views you add into it and will automatically use shared.html template. The rendered output is echoed to the browser. This API also implements the concept of Layouts, which is later used in ApiFrontend* ApiFrontend implements page routing by including page/* classes or using templates/default/page/* templates. The page is inserted inside <?Content?> region of shared.html file. This class also implements method which is called if page is not found. Finally sub-page functionality is also implemented here.
Which class is right for your application? In most cases, here is a simple way to determine:* Will your application output HTML? If no - use ApiCLI* Will your application have more than one page? If no - use ApiWeb* Will your application use un-usual page pattern? if yes - use ApiWeb* Otherwise use ApiFrontend.## Use of ApiCLI	Apart from the direct use, you can also use ApiCLI as a cron handler. Because you are using models directly you would be responsible for handling any exceptions yourself. ```include'atk4/loader.php';$api = new ApiCLI('myproj');$api->dbConnect();$jobs=$api->add('Model_Job')->addCondition('st','pending');foreach($jobs as $junk){  $jobs->set('st','processing')->save();  try {    $jobs->process();    $jobs['st']='done';  }catch(Exception $e){    $jobs->recordException($e);    $jobs['st']='failed';  }  $jobs->save();}
```

In this pattern you will be able to process multiple jobs even if some of them fail and will not run into situation when failed job is retried continuously.Try not to make the original file too big, create a controller instead which would do things for you.If you are looking to embed all functionality into a single file, you can declare number of classes after including the loader.## Using ApiCLI as an isolation environment
Because Agile Toolkit is static-safe, you can create ApiCLI from another class and run certain operations or tests inside ApiCLI without impact on the rest of application. This can be done for safety or security considerations, but practically you can create instance of ApiCLI even if you are inside other API.## ApiWeb - Typical use-cases
There are no limitations on how many Application classes you could create. Every time you find a new pattern in your web application development you can create your own application class. Often it's easier to create it on top of ApiWeb instead of using ApiFrontend, simply because the routing of ApiFrontend would not be relevant.One design pattern when you would want to use ApiWeb is when you do not want to use page rewriting and front controller. Instead you would want each URL to hit into the target file which would define how it would perform. The situation is for example when you are willing to to create a stand-alone URL independent from the rest of your application.The installer could be a stand-alone application, which should run independently from the rest of your software and perform database migration, add-on installations and more. Using ApiWeb as a basis is quite convenient, because you could direct browser directly to your install.php file.You can also use ApiWeb for a test-cases. With a separate API most of your application would not be activated and therefore you can focus on testing individual features. Finally you can use ApiWeb to share fragments of your code with others. It's quite handy to embed classes into a file along with a custom use of API. Below is example which allows user to specify two numbers and calculates the sum, however the whole implementation is packed into a single file. You can send such a file to anyone who have Agile Toolkit installed and they would simply need to put it into the application folder to make it work.=*(it's a good idea to use schema auto-generation add-on inside your models if you share them)*
```include'atk4/loader.php';$api=new ApiWeb();$api->add('jUI'); $f=$api->add('Form');$f->addField('line','a');$f->addField('line','b');$f->addField('line','result');$f->addSubmit(); if($f->isSubmitted()){	$f->getElement('result')->js()->val(        $f->get('a')+$f->get('b')    )->execute();}```
## Creating your own Application ClassWhen you start your new application with Agile Toolkit you should start by creating your application class. Typically the examples suggest you to create lib/Frontend.php, although you may name it the way you like. If your Application class is located elsewhere you may need to manually include it inside your `index.php`. Typically the job of an application class is to initialize your application by adding controllers and defining some core logic. Sometimes it's sensible to divide your functionality into two classes - base application class and extended application. This is the best approach if you need to white-label your application or 