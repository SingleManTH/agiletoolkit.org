# Confused Object-Orientation
I often hear from developers how good they are with Object Oriented design and then they design all their classes without extending anything. Similarly - many frameworks claim to be object-oriented, yet they fail to grasp the core concepts of Object-Oriented design:*Abstraction.*When you write object-oriented code, you don't just do it for the sake of writing. You do it to hide the complexity of your implementation and make it interchangeable.For example, in Agile Toolkit you can make take a sophisticated web page and replace "Grid" view with "Lister" view. It will retain most of it's functionality but will be presented differently. Similarly you can substitute one model with another and have the UI automatically adopt to it.The other big problem is that there is a large portion of libraries for PHP which do not rely on other libraries. They produce huge monolithic classes which can offer very little. A good example would be all those API libraries you download from facebook, twitter, etc. They pack up requests into CURL and will send them away within a 1000-line class, while the same functionality can be done using native SOAP implementation in 10 lines. I'm not saying SOAP is good, but it's a good example how you can rely on existing technology to make your life simpler.With Agile Toolkit you will have a huge amount of objects which you'll rely on. Clearly their implementation is not ideal, they might lack some features but any class is interchangeable and can be substituted by your own implementation. This modularity is a huge benefit of Agile Toolkit and once you learn how to override existing methods in classes, you will have no boundaries in Agile Toolkit.
## Legacy and Backwards Compatibility	
As the frameworks make it to their 2.0, many of them loose most of their adopters who simply don't want to learn completely new framework. This will not happen with Agile Toolkit and here is why:1. Agile Toolkit is already in it's 4.X versions. There have been a lot of movement in the past and a lot of things have settled down.2. Most of things in Agile Toolkit is interchangeable. If you like the implementation of "Menu" from a previous version of Agile Toolkit, it can still work.3. New version come with compatibility controller, which can emulate functionality of a previous version.Learning Agile Toolkit is a good investment as the framework will be there for a while and clearly have it's goals right.## Focusing on HOW versus WHAT
Some features such as “timestamps” or “soft delete” are often used on web projects and many frameworks have added support for them. Agile Toolkit have introduced the concept of Conditions and Behaviors in Models and it allows a seamless implementation of timestamps and soft deletes.Often Agile Toolkit would provide you a way how you can implement things on your own instead of coming up with all the possible solutions for your future problems.## Educating Developers	With many frameworks, when you ask “How can I implement X” the solution would be already built-in into a module. How can you implement CRUD in YII? Obviously - use the generator. What if you don't want to?In Agile Toolkit we try to educated developers how each individual component is built and how he could create an alternative implementation. In a way - the core of Agile Toolkit is more open and more fluid.## Avoiding Over-Use Objects	If you have programmed in Smalltalk or Java you would know that all the primitive types (numbers, strings, chars) are objects. That's the decision in language design and the frameworks built in those languages extensively use objects for every possible thing. In PHP it relies on a supplemental use of Objects. Strings, Numbers, Arrays are still a proper and awesome features of the language even through you can't extend them. You can't overload operations and that's fine. 
We understand that PHP is the way it is and we continue and Agile Toolkit does not attempt to artificially introduce a layer to wrap everything into a meaningless layer of objects.As you write your logic in Agile Toolkit, you do things in the regular way. If you need to validate an email, you can use var_filter or a regexp. Agile Toolkit will not wrap it inside a validator object for you. If you want - you can create class like that yourself and distribute it as an add-on.## Agile Toolkit is What You Make of It	With Agile Toolkit you can develop command-line software. The features of Agile Toolkit is implemented by it's Application class and you can pick the one you like best. If don't need routing and database connection, use less-powerful application class:```include'../atk4/loader.php';$api=new ApiWeb();$api->add('jUI');$f=$api->add('Form');$f->addField('line','a')->set(2);$f->addField('line','b')->set(2);$f->addField('line','result')->set(2);$f->addButton('sum');if($f->isSubmitted()){	$f->getElement('result')->js()		->val($f->get('a')+$f->get('b'))->execute();}```
